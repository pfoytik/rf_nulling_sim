<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D RF Nulling Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .control-group label {
            font-weight: bold;
            color: #333;
            font-size: 14px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-container input[type="range"] {
            flex: 1;
        }
        .value-display {
            min-width: 50px;
            text-align: right;
            font-family: monospace;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }
        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .canvas-container {
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #000;
            position: relative;
        }
        .canvas-title {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-weight: bold;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 3px;
        }
        .explanation {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #2196f3;
        }
        .key-concepts {
            background: #f3e5f5;
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #9c27b0;
        }
        h1 { color: #1976d2; margin-top: 0; }
        h3 { color: #333; margin-top: 0; }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #2196f3;
            color: white;
            cursor: pointer;
            font-size: 14px;
            margin: 2px;
        }
        button:hover {
            background: #1976d2;
        }
        .info-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border-radius: 3px;
            z-index: 100;
        }
        .array-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .array-type-selector input[type="radio"] {
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>3D RF Nulling: Understanding Spatial Dimensions</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Array Type</label>
                <div class="array-type-selector">
                    <label><input type="radio" name="arrayType" value="linear" checked> Linear</label>
                    <label><input type="radio" name="arrayType" value="planar"> Planar (2D)</label>
                </div>
            </div>
            
            <div class="control-group">
                <label>Array Size</label>
                <div class="slider-container">
                    <input type="range" id="arraySize" min="2" max="8" step="1" value="4">
                    <span class="value-display" id="arraySizeValue">4</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Element Spacing (λ)</label>
                <div class="slider-container">
                    <input type="range" id="spacing" min="0.3" max="1.0" step="0.1" value="0.5">
                    <span class="value-display" id="spacingValue">0.5</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Null Azimuth (°)</label>
                <div class="slider-container">
                    <input type="range" id="nullAzimuth" min="-90" max="90" step="5" value="30">
                    <span class="value-display" id="nullAzimuthValue">30°</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Null Elevation (°)</label>
                <div class="slider-container">
                    <input type="range" id="nullElevation" min="-45" max="45" step="5" value="0">
                    <span class="value-display" id="nullElevationValue">0°</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Actions</label>
                <div>
                    <button id="adaptiveNull3D">3D Adaptive Null</button>
                    <button id="resetArray">Reset Array</button>
                    <button id="randomizeArray">Randomize</button>
                    <button id="toggleAnimation">Toggle Rotation</button>
                </div>
            </div>
        </div>

        <div class="controls" id="elementControls" style="background: #f0f8ff; border-left: 4px solid #2196f3;">
            <h3 style="grid-column: 1/-1; margin: 0 0 10px 0; color: #1976d2;">Individual Element Controls</h3>
        </div>

        <div class="visualization-container">
            <div class="canvas-container">
                <div class="canvas-title">3D Radiation Pattern</div>
                <div class="info-panel" id="patternInfo">
                    Loading 3D visualization...
                </div>
            </div>
            <div class="canvas-container">
                <div class="canvas-title">Array Geometry & Phase</div>
                <div class="info-panel" id="arrayInfo">
                    Array configuration...
                </div>
            </div>
        </div>

        <div class="explanation">
            <h3>3D RF Nulling Concepts:</h3>
            <p><strong>Spherical Coordinates:</strong> Real interference sources are located by azimuth (θ) and elevation (φ) angles. A complete null must suppress signals from a specific point in 3D space.</p>
            
            <p><strong>Linear vs Planar Arrays:</strong></p>
            <p>• <strong>Linear Array:</strong> Controls nulling in one plane (2D slice of 3D space)</p>
            <p>• <strong>Planar Array:</strong> Full 3D control - can create nulls at any azimuth AND elevation</p>
            
            <p><strong>Degrees of Freedom:</strong></p>
            <p>• Linear N-element array: N-1 controllable nulls in one plane</p>
            <p>• Planar M×N array: (M×N-1) controllable nulls in full 3D space</p>
        </div>

        <div class="key-concepts">
            <h3>Key 3D Insights:</h3>
            <p>• <strong>Elevation Matters:</strong> Satellites, aircraft, and tall buildings create interference from above/below</p>
            <p>• <strong>Planar Advantage:</strong> Switch to planar array - now you can null at any elevation angle!</p>
            <p>• <strong>3D Adaptive:</strong> The algorithm must optimize in both azimuth and elevation simultaneously</p>
            <p>• <strong>Pattern Complexity:</strong> 3D patterns show lobes and nulls throughout space, not just in one plane</p>
            <p id="nullDepth3D" style="font-weight: bold; margin-top: 10px;"></p>
        </div>
    </div>

    <script>
        // Global variables
        let scene1, scene2, renderer1, renderer2, camera1, camera2;
        let patternMesh, arrayMesh;
        let elements = [];
        let animationRunning = false;
        let animationId;

        // Array configuration
        let arrayType = 'linear';
        let arraySize = 4;
        let spacing = 0.5;
        let nullAzimuth = 30;
        let nullElevation = 0;

        // Initialize the 3D scenes
        function init3D() {
            const containers = document.querySelectorAll('.canvas-container');
            
            // Scene 1: 3D Radiation Pattern
            scene1 = new THREE.Scene();
            camera1 = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            renderer1 = new THREE.WebGLRenderer({ antialias: true });
            renderer1.setSize(600, 400);
            renderer1.setClearColor(0x001122);
            containers[0].appendChild(renderer1.domElement);
            camera1.position.set(5, 3, 5);
            camera1.lookAt(0, 0, 0);

            // Scene 2: Array Geometry
            scene2 = new THREE.Scene();
            camera2 = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            renderer2 = new THREE.WebGLRenderer({ antialias: true });
            renderer2.setSize(600, 400);
            renderer2.setClearColor(0x112200);
            containers[1].appendChild(renderer2.domElement);
            camera2.position.set(3, 3, 3);
            camera2.lookAt(0, 0, 0);

            // Add lights
            const light1 = new THREE.AmbientLight(0x404040, 0.4);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.6);
            light2.position.set(5, 5, 5);
            scene1.add(light1.clone());
            scene1.add(light2.clone());
            scene2.add(light1.clone());
            scene2.add(light2.clone());

            // Add coordinate axes
            const axesHelper1 = new THREE.AxesHelper(2);
            const axesHelper2 = new THREE.AxesHelper(2);
            scene1.add(axesHelper1);
            scene2.add(axesHelper2);

            initializeArray();
            updateVisualization();
        }

        function initializeArray() {
            elements = [];
            
            if (arrayType === 'linear') {
                // Linear array along X-axis
                for (let i = 0; i < arraySize; i++) {
                    elements.push({
                        position: new THREE.Vector3((i - (arraySize-1)/2) * spacing, 0, 0),
                        amplitude: 1.0,
                        phase: 0.0
                    });
                }
            } else {
                // Planar array (square grid)
                const gridSize = Math.ceil(Math.sqrt(arraySize));
                let elementCount = 0;
                for (let x = 0; x < gridSize && elementCount < arraySize; x++) {
                    for (let y = 0; y < gridSize && elementCount < arraySize; y++) {
                        elements.push({
                            position: new THREE.Vector3(
                                (x - (gridSize-1)/2) * spacing,
                                (y - (gridSize-1)/2) * spacing,
                                0
                            ),
                            amplitude: 1.0,
                            phase: 0.0
                        });
                        elementCount++;
                    }
                }
            }
        }

        function calculate3DArrayFactor(azimuth, elevation) {
            const azimuthRad = azimuth * Math.PI / 180;
            const elevationRad = elevation * Math.PI / 180;
            
            // Direction vector
            const kx = 2 * Math.PI * Math.cos(elevationRad) * Math.cos(azimuthRad);
            const ky = 2 * Math.PI * Math.cos(elevationRad) * Math.sin(azimuthRad);
            const kz = 2 * Math.PI * Math.sin(elevationRad);

            let realSum = 0;
            let imagSum = 0;

            elements.forEach(element => {
                const phaseRad = element.phase * Math.PI / 180;
                const spatialPhase = kx * element.position.x + ky * element.position.y + kz * element.position.z;
                const totalPhase = spatialPhase + phaseRad;

                realSum += element.amplitude * Math.cos(totalPhase);
                imagSum += element.amplitude * Math.sin(totalPhase);
            });

            return Math.sqrt(realSum * realSum + imagSum * imagSum);
        }

        function create3DRadiationPattern() {
            // Remove existing pattern and ALL null indicators
            const objectsToRemove = [];
            scene1.traverse(child => {
                if (child.isMesh && (child.userData.isPattern || child.userData.isNullIndicator)) {
                    objectsToRemove.push(child);
                }
            });
            objectsToRemove.forEach(obj => scene1.remove(obj));

            // Create spherical pattern
            const geometry = new THREE.SphereGeometry(1, 32, 16);
            const vertices = geometry.attributes.position.array;
            const colors = new Float32Array(vertices.length);

            let maxAF = 0;
            const afValues = [];

            // Calculate array factor for each vertex
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                const z = vertices[i + 2];

                // Convert to spherical coordinates
                const azimuth = Math.atan2(y, x) * 180 / Math.PI;
                const elevation = Math.asin(z) * 180 / Math.PI;

                const af = calculate3DArrayFactor(azimuth, elevation);
                afValues.push(af);
                maxAF = Math.max(maxAF, af);
            }

            // Scale vertices by array factor and color by intensity
            for (let i = 0; i < vertices.length; i += 3) {
                const afIndex = i / 3;
                const normalizedAF = afValues[afIndex] / maxAF;
                
                // Scale radius by array factor
                vertices[i] *= normalizedAF * 2;
                vertices[i + 1] *= normalizedAF * 2;
                vertices[i + 2] *= normalizedAF * 2;

                // Color based on intensity (blue = low, red = high)
                colors[i] = normalizedAF; // Red
                colors[i + 1] = 0.2; // Green
                colors[i + 2] = 1 - normalizedAF; // Blue
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.attributes.position.needsUpdate = true;

            const material = new THREE.MeshBasicMaterial({ 
                vertexColors: true, 
                wireframe: false,
                transparent: true,
                opacity: 0.8
            });
            
            patternMesh = new THREE.Mesh(geometry, material);
            patternMesh.userData.isPattern = true; // Mark for cleanup
            scene1.add(patternMesh);

            // Add null direction indicator
            const nullDirection = new THREE.Vector3();
            const azRad = nullAzimuth * Math.PI / 180;
            const elRad = nullElevation * Math.PI / 180;
            nullDirection.x = Math.cos(elRad) * Math.cos(azRad);
            nullDirection.y = Math.cos(elRad) * Math.sin(azRad);
            nullDirection.z = Math.sin(elRad);
            nullDirection.multiplyScalar(3);

            const nullGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const nullMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const nullIndicator = new THREE.Mesh(nullGeometry, nullMaterial);
            nullIndicator.position.copy(nullDirection);
            nullIndicator.lookAt(nullDirection.clone().multiplyScalar(2));
            nullIndicator.userData.isNullIndicator = true; // Mark for cleanup
            scene1.add(nullIndicator);

            // Calculate null depth
            const nullAF = calculate3DArrayFactor(nullAzimuth, nullElevation);
            const nullDepth = maxAF > 0 ? -20 * Math.log10(nullAF / maxAF) : 0;
            
            document.getElementById('nullDepth3D').textContent = 
                `3D Null Depth: ${nullDepth.toFixed(1)} dB at (${nullAzimuth}°, ${nullElevation}°)`;
            document.getElementById('nullDepth3D').style.color = 
                nullDepth > 30 ? '#388e3c' : nullDepth > 15 ? '#f57c00' : '#d32f2f';
        }

        function createElementControls() {
            const container = document.getElementById('elementControls');
            
            // Clear existing controls except the title
            while (container.children.length > 1) {
                container.removeChild(container.lastChild);
            }

            elements.forEach((element, i) => {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'control-group';
                
                // Element label
                const label = document.createElement('label');
                label.textContent = `Element ${i + 1}`;
                label.style.color = '#1976d2';
                controlDiv.appendChild(label);

                // Amplitude control
                const ampContainer = document.createElement('div');
                ampContainer.className = 'slider-container';
                ampContainer.innerHTML = `
                    <span style="min-width: 60px; font-size: 12px;">Amplitude:</span>
                    <input type="range" id="amp3d${i}" min="0" max="2" step="0.1" value="${element.amplitude}">
                    <span class="value-display" id="ampValue3d${i}">${element.amplitude.toFixed(1)}</span>
                `;
                controlDiv.appendChild(ampContainer);

                // Phase control
                const phaseContainer = document.createElement('div');
                phaseContainer.className = 'slider-container';
                phaseContainer.innerHTML = `
                    <span style="min-width: 60px; font-size: 12px;">Phase:</span>
                    <input type="range" id="phase3d${i}" min="-180" max="180" step="5" value="${element.phase}">
                    <span class="value-display" id="phaseValue3d${i}">${element.phase.toFixed(0)}°</span>
                `;
                controlDiv.appendChild(phaseContainer);

                container.appendChild(controlDiv);

                // Add event listeners
                setTimeout(() => {
                    const ampSlider = document.getElementById(`amp3d${i}`);
                    const phaseSlider = document.getElementById(`phase3d${i}`);
                    
                    if (ampSlider) {
                        ampSlider.addEventListener('input', (e) => {
                            elements[i].amplitude = parseFloat(e.target.value);
                            document.getElementById(`ampValue3d${i}`).textContent = elements[i].amplitude.toFixed(1);
                            updateVisualization();
                            render();
                        });
                    }

                    if (phaseSlider) {
                        phaseSlider.addEventListener('input', (e) => {
                            elements[i].phase = parseFloat(e.target.value);
                            document.getElementById(`phaseValue3d${i}`).textContent = elements[i].phase.toFixed(0) + '°';
                            updateVisualization();
                            render();
                        });
                    }
                }, 100);
            });
        }

        function createArrayVisualization() {
            // Clear existing array (keep lights and axes)
            const objectsToRemove = [];
            scene2.traverse(child => {
                if (child.isMesh && child.userData.isArrayElement) {
                    objectsToRemove.push(child);
                }
                if (child.isSprite || child.isLine) {
                    objectsToRemove.push(child);
                }
            });
            objectsToRemove.forEach(obj => scene2.remove(obj));

            // Draw array elements
            const colors = [0x4caf50, 0x2196f3, 0xff9800, 0x9c27b0, 0xf44336, 0x00bcd4, 0x795548, 0x607d8b];
            
            // Calculate resultant vector for null direction
            let resultantReal = 0, resultantImag = 0;
            const nullAzRad = nullAzimuth * Math.PI / 180;
            const nullElRad = nullElevation * Math.PI / 180;
            
            elements.forEach((element, i) => {
                // Element sphere
                const geometry = new THREE.SphereGeometry(0.1, 8, 6);
                const material = new THREE.MeshPhongMaterial({ color: colors[i % colors.length] });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(element.position);
                sphere.userData.isArrayElement = true;
                scene2.add(sphere);

                // Phase circle guide (faint circle showing phase rotation)
                const circleGeometry = new THREE.RingGeometry(0.4, 0.42, 32);
                const circleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x666666, 
                    transparent: true, 
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const circle = new THREE.Mesh(circleGeometry, circleMaterial);
                circle.position.copy(element.position);
                circle.position.z += 0.25;
                circle.userData.isArrayElement = true;
                scene2.add(circle);

                // Amplitude scale rings
                for (let scale of [0.25, 0.5, 0.75, 1.0]) {
                    const ringGeometry = new THREE.RingGeometry(scale * 0.25, scale * 0.25 + 0.01, 16);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x888888, 
                        transparent: true, 
                        opacity: 0.2,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.copy(element.position);
                    ring.position.z += 0.24;
                    ring.userData.isArrayElement = true;
                    scene2.add(ring);
                }

                // Phase markers (0°, 90°, 180°, 270°)
                for (let angle of [0, 90, 180, 270]) {
                    const markerRad = angle * Math.PI / 180;
                    const markerGeometry = new THREE.SphereGeometry(0.02, 4, 4);
                    const markerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x999999,
                        transparent: true,
                        opacity: 0.5
                    });
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.copy(element.position);
                    marker.position.x += 0.4 * Math.cos(markerRad);
                    marker.position.y += 0.4 * Math.sin(markerRad);
                    marker.position.z += 0.25;
                    marker.userData.isArrayElement = true;
                    scene2.add(marker);
                }

                // Calculate phase vector position
                const phaseRad = element.phase * Math.PI / 180;
                const vectorLength = element.amplitude * 0.5;
                const vectorPos = element.position.clone();
                vectorPos.x += vectorLength * Math.cos(phaseRad);
                vectorPos.y += vectorLength * Math.sin(phaseRad);
                vectorPos.z += 0.3;

                // Vector line from sphere to cone (dotted line)
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    element.position,
                    vectorPos
                ]);
                const lineMaterial = new THREE.LineDashedMaterial({ 
                    color: colors[i % colors.length],
                    dashSize: 0.05,
                    gapSize: 0.02,
                    linewidth: 2
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.computeLineDistances();
                line.userData.isArrayElement = true;
                scene2.add(line);

                // Phase vector cone
                const vectorGeometry = new THREE.ConeGeometry(0.03, 0.12, 8);
                const vectorMaterial = new THREE.MeshBasicMaterial({ color: colors[i % colors.length] });
                const vector = new THREE.Mesh(vectorGeometry, vectorMaterial);
                vector.position.copy(vectorPos);
                vector.lookAt(vectorPos.x + Math.cos(phaseRad), vectorPos.y + Math.sin(phaseRad), vectorPos.z);
                vector.userData.isArrayElement = true;
                scene2.add(vector);

                // Calculate contribution to resultant vector at null direction
                const spatialPhase = 2 * Math.PI * (
                    element.position.x * Math.cos(nullElRad) * Math.cos(nullAzRad) +
                    element.position.y * Math.cos(nullElRad) * Math.sin(nullAzRad) +
                    element.position.z * Math.sin(nullElRad)
                ) * spacing;
                const totalPhase = spatialPhase + phaseRad;
                
                resultantReal += element.amplitude * Math.cos(totalPhase);
                resultantImag += element.amplitude * Math.sin(totalPhase);

                // Element label
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = 'white';
                context.font = '20px Arial';
                context.textAlign = 'center';
                context.fillText(`${i+1}`, 32, 35);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(element.position);
                sprite.position.z += 0.4;
                sprite.scale.set(0.3, 0.3, 1);
                scene2.add(sprite);
            });

            // Draw resultant vector (vector sum at null direction)
            const resultantMagnitude = Math.sqrt(resultantReal * resultantReal + resultantImag * resultantImag);
            const resultantPhase = Math.atan2(resultantImag, resultantReal);
            
            if (resultantMagnitude > 0.01) { // Only draw if significant
                const resultantPos = new THREE.Vector3(2, 0, 0.5); // Position for resultant display
                const resultantEndPos = resultantPos.clone();
                resultantEndPos.x += resultantMagnitude * Math.cos(resultantPhase) * 0.5;
                resultantEndPos.y += resultantMagnitude * Math.sin(resultantPhase) * 0.5;

                // Resultant vector line
                const resultantLineGeometry = new THREE.BufferGeometry().setFromPoints([
                    resultantPos,
                    resultantEndPos
                ]);
                
                // Color based on magnitude (green = small/good, red = large/poor)
                const resultantColor = resultantMagnitude < 0.5 ? 0x00ff00 : 
                                     resultantMagnitude < 1.0 ? 0xffff00 : 0xff0000;
                
                const resultantLineMaterial = new THREE.LineBasicMaterial({ 
                    color: resultantColor,
                    linewidth: 4
                });
                const resultantLine = new THREE.Line(resultantLineGeometry, resultantLineMaterial);
                resultantLine.userData.isArrayElement = true;
                scene2.add(resultantLine);

                // Resultant vector arrow head
                const resultantArrowGeometry = new THREE.ConeGeometry(0.05, 0.15, 8);
                const resultantArrowMaterial = new THREE.MeshBasicMaterial({ color: resultantColor });
                const resultantArrow = new THREE.Mesh(resultantArrowGeometry, resultantArrowMaterial);
                resultantArrow.position.copy(resultantEndPos);
                resultantArrow.lookAt(
                    resultantEndPos.x + Math.cos(resultantPhase),
                    resultantEndPos.y + Math.sin(resultantPhase),
                    resultantEndPos.z
                );
                resultantArrow.userData.isArrayElement = true;
                scene2.add(resultantArrow);

                // Resultant vector label
                const resultantCanvas = document.createElement('canvas');
                resultantCanvas.width = 128;
                resultantCanvas.height = 64;
                const resultantContext = resultantCanvas.getContext('2d');
                resultantContext.fillStyle = resultantMagnitude < 0.5 ? '#00ff00' : 
                                           resultantMagnitude < 1.0 ? '#ffff00' : '#ff0000';
                resultantContext.font = '16px Arial';
                resultantContext.textAlign = 'center';
                resultantContext.fillText('Resultant', 64, 20);
                resultantContext.fillText(`${resultantMagnitude.toFixed(2)}`, 64, 40);
                
                const resultantTexture = new THREE.CanvasTexture(resultantCanvas);
                const resultantSpriteMaterial = new THREE.SpriteMaterial({ map: resultantTexture });
                const resultantSprite = new THREE.Sprite(resultantSpriteMaterial);
                resultantSprite.position.set(2, 0, 0.8);
                resultantSprite.scale.set(0.6, 0.3, 1);
                scene2.add(resultantSprite);
            }

            // Add legend for amplitude scales
            const legendCanvas = document.createElement('canvas');
            legendCanvas.width = 200;
            legendCanvas.height = 100;
            const legendContext = legendCanvas.getContext('2d');
            legendContext.fillStyle = '#ffffff';
            legendContext.font = '12px Arial';
            legendContext.textAlign = 'left';
            legendContext.fillText('Amplitude Scale:', 10, 15);
            legendContext.fillText('Inner ring: 0.5', 10, 30);
            legendContext.fillText('Outer ring: 2.0', 10, 45);
            legendContext.fillText('Phase markers:', 10, 65);
            legendContext.fillText('0°→ 90°↑ 180°← 270°↓', 10, 80);
            
            const legendTexture = new THREE.CanvasTexture(legendCanvas);
            const legendSpriteMaterial = new THREE.SpriteMaterial({ map: legendTexture });
            const legendSprite = new THREE.Sprite(legendSpriteMaterial);
            legendSprite.position.set(-2, -1.5, 0.5);
            legendSprite.scale.set(1, 0.5, 1);
            scene2.add(legendSprite);
        }

        function updateVisualization() {
            create3DRadiationPattern();
            createArrayVisualization();
            createElementControls();
            
            document.getElementById('patternInfo').innerHTML = 
                `Pattern Type: ${arrayType}<br>Elements: ${elements.length}<br>3D Control: ${arrayType === 'planar' ? 'Yes' : 'Limited'}`;
            document.getElementById('arrayInfo').innerHTML = 
                `Spacing: ${spacing}λ<br>Null: (${nullAzimuth}°, ${nullElevation}°)<br>Type: ${arrayType}`;
        }

        function randomizeArray() {
            elements.forEach(element => {
                element.amplitude = 0.5 + Math.random() * 1.0; // 0.5 to 1.5
                element.phase = (Math.random() - 0.5) * 360; // -180 to +180
            });
            updateVisualization();
            render();
        }

        function adaptive3DNulling() {
            // Simple 3D optimization - adjust phases to minimize signal at null direction
            const iterations = 50;
            const learningRate = 2;
            
            let bestConfig = elements.map(el => ({...el}));
            let bestNullDepth = 0;
            
            // Try multiple random starting points for better optimization
            for (let trial = 0; trial < 10; trial++) {
                // Start with current configuration
                let testElements = elements.map(el => ({...el}));
                
                for (let iter = 0; iter < iterations; iter++) {
                    testElements.forEach((element, i) => {
                        if (i === 0) return; // Keep element 1 as phase reference
                        
                        const originalPhase = element.phase;
                        
                        // Try phase adjustments
                        element.phase += learningRate;
                        const af1 = calculate3DArrayFactor(nullAzimuth, nullElevation);
                        
                        element.phase = originalPhase - learningRate;
                        const af2 = calculate3DArrayFactor(nullAzimuth, nullElevation);
                        
                        // Keep better phase
                        if (af2 < af1) {
                            // af2 is better (keep the -learningRate adjustment)
                        } else {
                            element.phase = originalPhase + learningRate;
                            const af3 = calculate3DArrayFactor(nullAzimuth, nullElevation);
                            if (af3 >= af1) {
                                element.phase = originalPhase; // No improvement
                            }
                        }
                        
                        // Wrap phase to [-180, 180]
                        while (element.phase > 180) element.phase -= 360;
                        while (element.phase < -180) element.phase += 360;
                    });
                }
                
                // Evaluate this configuration
                const finalAF = calculate3DArrayFactor(nullAzimuth, nullElevation);
                
                // Calculate max AF for null depth calculation
                let maxAF = 0;
                for (let testAngle = 0; testAngle < 360; testAngle += 10) {
                    const af = calculate3DArrayFactor(testAngle, 0);
                    maxAF = Math.max(maxAF, af);
                }
                
                const nullDepth = maxAF > 0 ? -20 * Math.log10(finalAF / maxAF) : 0;
                
                if (nullDepth > bestNullDepth) {
                    bestNullDepth = nullDepth;
                    bestConfig = testElements.map(el => ({...el}));
                }
            }
            
            // Apply best configuration to actual elements
            elements.forEach((element, i) => {
                element.phase = bestConfig[i].phase;
                element.amplitude = bestConfig[i].amplitude;
            });
            
            // Force complete UI and graphics update
            updateVisualization();
            render();
            
            // Update the individual control sliders to reflect new values
            setTimeout(() => {
                elements.forEach((element, i) => {
                    const phaseSlider = document.getElementById(`phase3d${i}`);
                    const phaseValue = document.getElementById(`phaseValue3d${i}`);
                    const ampSlider = document.getElementById(`amp3d${i}`);
                    const ampValue = document.getElementById(`ampValue3d${i}`);
                    
                    if (phaseSlider) {
                        phaseSlider.value = element.phase;
                        if (phaseValue) {
                            phaseValue.textContent = element.phase.toFixed(0) + '°';
                        }
                    }
                    
                    if (ampSlider) {
                        ampSlider.value = element.amplitude;
                        if (ampValue) {
                            ampValue.textContent = element.amplitude.toFixed(1);
                        }
                    }
                });
                
                // Show results after UI is updated
                setTimeout(() => {
                    alert(`3D Adaptive Nulling Complete!\n` +
                          `• Target: (${nullAzimuth}°, ${nullElevation}°)\n` +
                          `• Achieved null depth: ${bestNullDepth.toFixed(1)} dB\n` +
                          `• Array type: ${arrayType}\n` +
                          `• Elements: ${elements.length}\n\n` +
                          `Check the updated phase vectors and radiation pattern!`);
                }, 100);
            }, 200);
        }

        function resetArray() {
            elements.forEach(element => {
                element.amplitude = 1.0;
                element.phase = 0.0;
            });
            updateVisualization();
        }

        function toggleAnimation() {
            if (animationRunning) {
                cancelAnimationFrame(animationId);
                animationRunning = false;
                document.getElementById('toggleAnimation').textContent = 'Start Rotation';
            } else {
                animationRunning = true;
                document.getElementById('toggleAnimation').textContent = 'Stop Rotation';
                animate();
            }
        }

        function animate() {
            if (!animationRunning) return;
            
            animationId = requestAnimationFrame(animate);
            
            // Rotate cameras
            const time = Date.now() * 0.001;
            camera1.position.x = Math.cos(time * 0.5) * 5;
            camera1.position.z = Math.sin(time * 0.5) * 5;
            camera1.lookAt(0, 0, 0);
            
            camera2.position.x = Math.cos(time * 0.3) * 3;
            camera2.position.z = Math.sin(time * 0.3) * 3;
            camera2.lookAt(0, 0, 0);
            
            renderer1.render(scene1, camera1);
            renderer2.render(scene2, camera2);
        }

        function render() {
            renderer1.render(scene1, camera1);
            renderer2.render(scene2, camera2);
        }

        // Event listeners
        document.querySelectorAll('input[name="arrayType"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                arrayType = e.target.value;
                initializeArray();
                updateVisualization();
                render();
            });
        });

        document.getElementById('arraySize').addEventListener('input', (e) => {
            arraySize = parseInt(e.target.value);
            document.getElementById('arraySizeValue').textContent = arraySize;
            initializeArray();
            updateVisualization();
            render();
        });

        document.getElementById('spacing').addEventListener('input', (e) => {
            spacing = parseFloat(e.target.value);
            document.getElementById('spacingValue').textContent = spacing;
            initializeArray();
            updateVisualization();
            render();
        });

        document.getElementById('nullAzimuth').addEventListener('input', (e) => {
            nullAzimuth = parseInt(e.target.value);
            document.getElementById('nullAzimuthValue').textContent = nullAzimuth + '°';
            updateVisualization();
            render();
        });

        document.getElementById('nullElevation').addEventListener('input', (e) => {
            nullElevation = parseInt(e.target.value);
            document.getElementById('nullElevationValue').textContent = nullElevation + '°';
            updateVisualization();
            render();
        });

        document.getElementById('adaptiveNull3D').addEventListener('click', adaptive3DNulling);
        document.getElementById('resetArray').addEventListener('click', resetArray);
        document.getElementById('randomizeArray').addEventListener('click', randomizeArray);
        document.getElementById('toggleAnimation').addEventListener('click', toggleAnimation);

        // Initialize when page loads
        window.addEventListener('load', () => {
            init3D();
            render();
        });
    </script>
</body>
</html>