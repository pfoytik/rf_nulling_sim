<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RF Nulling Simulation - Multi-Element Array</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-group label {
            font-weight: bold;
            color: #333;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider-container input[type="range"] {
            flex: 1;
        }
        .value-display {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 3px;
        }
        .plot-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
        }
        .element-controls {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            border-left: 4px solid #2196f3;
        }
        .element-row {
            display: grid;
            grid-template-columns: 60px 1fr 1fr;
            gap: 15px;
            align-items: center;
            margin-bottom: 10px;
        }
        .element-label {
            font-weight: bold;
            color: #1976d2;
            text-align: center;
        }
        .explanation {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            border-left: 4px solid #2196f3;
        }
        .key-concepts {
            background: #f3e5f5;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            border-left: 4px solid #9c27b0;
        }
        h1 { color: #1976d2; }
        h3 { color: #333; margin-top: 0; }
        .math { font-family: 'Times New Roman', serif; font-style: italic; }
        .button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: #2196f3;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #1976d2;
        }
        .secondary-btn {
            background: #ff9800 !important;
        }
        .secondary-btn:hover {
            background: #f57c00 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RF Nulling: Multi-Element Array Simulation</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Number of Elements</label>
                <div class="slider-container">
                    <input type="range" id="numElements" min="2" max="8" step="1" value="2">
                    <span class="value-display" id="numElementsValue">2</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Element Spacing (λ)</label>
                <div class="slider-container">
                    <input type="range" id="spacing" min="0.1" max="1.0" step="0.1" value="0.5">
                    <span class="value-display" id="spacingValue">0.5</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Target Null Direction (degrees)</label>
                <div class="slider-container">
                    <input type="range" id="nullAngle" min="-90" max="90" step="5" value="30">
                    <span class="value-display" id="nullAngleValue">30°</span>
                </div>
            </div>

            <div class="control-group">
                <label>Control Actions</label>
                <div class="button-row">
                    <button id="resetElements">Reset All</button>
                    <button id="randomize" class="secondary-btn">Randomize</button>
                    <button id="adaptiveNull">Adaptive Null</button>
                </div>
            </div>
        </div>

        <div class="element-controls" id="elementControls">
            <h3>Individual Element Controls</h3>
            <div id="elementSliders"></div>
        </div>

        <div class="plot-container">
            <div>
                <h3>Radiation Pattern (Polar)</h3>
                <canvas id="polarPlot" width="450" height="450"></canvas>
            </div>
            <div>
                <h3>Array Geometry & Elements</h3>
                <canvas id="arrayPlot" width="450" height="450"></canvas>
            </div>
        </div>

        <div class="explanation">
            <h3>Multi-Element Array Nulling:</h3>
            <p><strong>Degrees of Freedom:</strong> With N elements, you have N-1 independent degrees of freedom. This means you can theoretically create up to N-1 independent nulls!</p>
            
            <p><strong>Adaptive Nulling Power:</strong> More elements give adaptive algorithms much more flexibility. Even with amplitude mismatches, you can often achieve excellent nulling performance.</p>
            
            <p class="math">AF(θ) = Σ A<sub>n</sub> × e<sup>j(kd<sub>n</sub>×cos(θ) + φ<sub>n</sub>)</sup></p>
            
            <p>Where each element n has its own amplitude A<sub>n</sub> and phase φ<sub>n</sub></p>
        </div>

        <div class="key-concepts">
            <h3>Try These Experiments:</h3>
            <p>• <strong>Start Simple:</strong> Use 2 elements first, then increase to see the difference</p>
            <p>• <strong>Randomize:</strong> Click "Randomize" to simulate real-world amplitude/phase errors</p>
            <p>• <strong>Adaptive Power:</strong> See how "Adaptive Null" handles mismatched elements</p>
            <p>• <strong>Multiple Nulls:</strong> With 4+ elements, try creating nulls at multiple angles</p>
            <p id="nullDepth" style="font-weight: bold; color: #d32f2f; margin-top: 10px;"></p>
        </div>
    </div>

    <script>
        // Get canvas contexts
        const polarCanvas = document.getElementById('polarPlot');
        const polarCtx = polarCanvas.getContext('2d');
        const arrayCanvas = document.getElementById('arrayPlot');
        const arrayCtx = arrayCanvas.getContext('2d');

        // Get controls
        const numElementsSlider = document.getElementById('numElements');
        const spacingSlider = document.getElementById('spacing');
        const nullAngleSlider = document.getElementById('nullAngle');
        const resetBtn = document.getElementById('resetElements');
        const randomizeBtn = document.getElementById('randomize');
        const adaptiveNullBtn = document.getElementById('adaptiveNull');

        // Value displays
        const numElementsValue = document.getElementById('numElementsValue');
        const spacingValue = document.getElementById('spacingValue');
        const nullAngleValue = document.getElementById('nullAngleValue');

        // Array to store element parameters
        let elements = [];

        function initializeElements(numElements) {
            elements = [];
            for (let i = 0; i < numElements; i++) {
                elements.push({
                    amplitude: 1.0,
                    phase: 0.0,
                    position: i // Linear array
                });
            }
        }

        function createElementControls() {
            const numElements = parseInt(numElementsSlider.value);
            const container = document.getElementById('elementSliders');
            container.innerHTML = '';

            for (let i = 0; i < numElements; i++) {
                const row = document.createElement('div');
                row.className = 'element-row';

                // Element label
                const label = document.createElement('div');
                label.className = 'element-label';
                label.textContent = `El ${i+1}:`;
                row.appendChild(label);

                // Amplitude control
                const ampContainer = document.createElement('div');
                ampContainer.className = 'slider-container';
                const ampSlider = document.createElement('input');
                ampSlider.type = 'range';
                ampSlider.min = '0';
                ampSlider.max = '2';
                ampSlider.step = '0.1';
                ampSlider.value = elements[i].amplitude;
                ampSlider.id = `amp${i}`;
                const ampValue = document.createElement('span');
                ampValue.className = 'value-display';
                ampValue.textContent = elements[i].amplitude.toFixed(1);
                ampValue.id = `ampValue${i}`;
                ampContainer.appendChild(document.createTextNode('Amp: '));
                ampContainer.appendChild(ampSlider);
                ampContainer.appendChild(ampValue);
                row.appendChild(ampContainer);

                // Phase control
                const phaseContainer = document.createElement('div');
                phaseContainer.className = 'slider-container';
                const phaseSlider = document.createElement('input');
                phaseSlider.type = 'range';
                phaseSlider.min = '-180';
                phaseSlider.max = '180';
                phaseSlider.step = '5';
                phaseSlider.value = elements[i].phase;
                phaseSlider.id = `phase${i}`;
                const phaseValue = document.createElement('span');
                phaseValue.className = 'value-display';
                phaseValue.textContent = elements[i].phase.toFixed(0) + '°';
                phaseValue.id = `phaseValue${i}`;
                phaseContainer.appendChild(document.createTextNode('Phase: '));
                phaseContainer.appendChild(phaseSlider);
                phaseContainer.appendChild(phaseValue);
                row.appendChild(phaseContainer);

                container.appendChild(row);

                // Add event listeners
                ampSlider.addEventListener('input', (e) => {
                    elements[i].amplitude = parseFloat(e.target.value);
                    document.getElementById(`ampValue${i}`).textContent = elements[i].amplitude.toFixed(1);
                    updateDisplay();
                });

                phaseSlider.addEventListener('input', (e) => {
                    elements[i].phase = parseFloat(e.target.value);
                    document.getElementById(`phaseValue${i}`).textContent = elements[i].phase.toFixed(0) + '°';
                    updateDisplay();
                });
            }
        }

        function calculateMultiElementArrayFactor(theta, spacing, elements) {
            const thetaRad = theta * Math.PI / 180;
            const k = 2 * Math.PI; // Normalized wave number

            let realSum = 0;
            let imagSum = 0;

            elements.forEach((element, index) => {
                const phaseRad = element.phase * Math.PI / 180;
                const spatialPhase = k * spacing * element.position * Math.cos(thetaRad);
                const totalPhase = spatialPhase + phaseRad;

                realSum += element.amplitude * Math.cos(totalPhase);
                imagSum += element.amplitude * Math.sin(totalPhase);
            });

            return Math.sqrt(realSum * realSum + imagSum * imagSum);
        }

        function updateDisplay() {
            numElementsValue.textContent = numElementsSlider.value;
            spacingValue.textContent = spacingSlider.value;
            nullAngleValue.textContent = nullAngleSlider.value + '°';
            
            drawPlots();
        }

        function drawPolarPlot() {
            const centerX = polarCanvas.width / 2;
            const centerY = polarCanvas.height / 2;
            const radius = 180;

            polarCtx.clearRect(0, 0, polarCanvas.width, polarCanvas.height);

            // Draw grid
            polarCtx.strokeStyle = '#e0e0e0';
            polarCtx.lineWidth = 1;
            
            // Concentric circles
            for (let r = 30; r <= radius; r += 30) {
                polarCtx.beginPath();
                polarCtx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                polarCtx.stroke();
            }

            // Radial lines
            for (let angle = 0; angle < 360; angle += 30) {
                const rad = angle * Math.PI / 180;
                polarCtx.beginPath();
                polarCtx.moveTo(centerX, centerY);
                polarCtx.lineTo(
                    centerX + radius * Math.cos(rad - Math.PI/2),
                    centerY + radius * Math.sin(rad - Math.PI/2)
                );
                polarCtx.stroke();
            }

            // Draw angle labels
            polarCtx.fillStyle = '#666';
            polarCtx.font = '12px Arial';
            polarCtx.textAlign = 'center';
            
            const angles = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];
            angles.forEach(angle => {
                const rad = angle * Math.PI / 180;
                const x = centerX + (radius + 15) * Math.cos(rad - Math.PI/2);
                const y = centerY + (radius + 15) * Math.sin(rad - Math.PI/2) + 4;
                polarCtx.fillText(angle + '°', x, y);
            });

            // Calculate and draw radiation pattern
            const spacing = parseFloat(spacingSlider.value);

            polarCtx.strokeStyle = '#2196f3';
            polarCtx.lineWidth = 2;
            polarCtx.beginPath();

            let maxAF = 0;
            let minAF = Infinity;
            const afValues = [];
            
            // Calculate array factor for all angles
            for (let angle = 0; angle <= 360; angle += 1) {
                const af = calculateMultiElementArrayFactor(angle, spacing, elements);
                afValues.push(af);
                maxAF = Math.max(maxAF, af);
                minAF = Math.min(minAF, af);
            }

            // Calculate null depth at target angle
            const nullAngle = parseFloat(nullAngleSlider.value);
            const nullAF = calculateMultiElementArrayFactor(nullAngle, spacing, elements);
            const nullDepthDB = maxAF > 0 ? -20 * Math.log10(nullAF / maxAF) : 0;

            // Update null depth display
            const nullDepthElement = document.getElementById('nullDepth');
            if (nullDepthDB > 60) {
                nullDepthElement.textContent = `Null Depth: >60 dB (Excellent!)`;
                nullDepthElement.style.color = '#388e3c';
            } else if (nullDepthDB > 30) {
                nullDepthElement.textContent = `Null Depth: ${nullDepthDB.toFixed(1)} dB (Good)`;
                nullDepthElement.style.color = '#f57c00';
            } else if (nullDepthDB > 10) {
                nullDepthElement.textContent = `Null Depth: ${nullDepthDB.toFixed(1)} dB (Fair)`;
                nullDepthElement.style.color = '#ff5722';
            } else {
                nullDepthElement.textContent = `Null Depth: ${nullDepthDB.toFixed(1)} dB (Poor)`;
                nullDepthElement.style.color = '#d32f2f';
            }

            // Draw pattern
            if (maxAF > 0) {
                afValues.forEach((af, i) => {
                    const angle = i;
                    const normalizedAF = af / maxAF;
                    const plotRadius = normalizedAF * radius;
                    
                    const rad = angle * Math.PI / 180;
                    const x = centerX + plotRadius * Math.cos(rad - Math.PI/2);
                    const y = centerY + plotRadius * Math.sin(rad - Math.PI/2);
                    
                    if (i === 0) {
                        polarCtx.moveTo(x, y);
                    } else {
                        polarCtx.lineTo(x, y);
                    }
                });
            }
            
            polarCtx.closePath();
            polarCtx.stroke();

            // Highlight null direction
            const nullRad = nullAngle * Math.PI / 180;
            polarCtx.strokeStyle = '#f44336';
            polarCtx.lineWidth = 2;
            polarCtx.beginPath();
            polarCtx.moveTo(centerX, centerY);
            polarCtx.lineTo(
                centerX + radius * Math.cos(nullRad - Math.PI/2),
                centerY + radius * Math.sin(nullRad - Math.PI/2)
            );
            polarCtx.stroke();

            // Add pattern info
            polarCtx.fillStyle = '#333';
            polarCtx.font = '11px Arial';
            polarCtx.textAlign = 'left';
            polarCtx.fillText(`Elements: ${elements.length}`, 10, 25);
            polarCtx.fillText(`Max AF: ${maxAF.toFixed(2)}`, 10, 40);
        }

        function drawArrayGeometry() {
            const centerX = arrayCanvas.width / 2;
            const centerY = arrayCanvas.height / 2;
            const spacing = parseFloat(spacingSlider.value);

            arrayCtx.clearRect(0, 0, arrayCanvas.width, arrayCanvas.height);

            // Draw coordinate system
            arrayCtx.strokeStyle = '#e0e0e0';
            arrayCtx.lineWidth = 1;
            
            // Grid lines
            for (let x = 0; x < arrayCanvas.width; x += 40) {
                arrayCtx.beginPath();
                arrayCtx.moveTo(x, 0);
                arrayCtx.lineTo(x, arrayCanvas.height);
                arrayCtx.stroke();
            }
            
            for (let y = 0; y < arrayCanvas.height; y += 40) {
                arrayCtx.beginPath();
                arrayCtx.moveTo(0, y);
                arrayCtx.lineTo(arrayCanvas.width, y);
                arrayCtx.stroke();
            }

            // Calculate display parameters
            const elementSpacing = spacing * 40; // Scale for display
            const totalWidth = (elements.length - 1) * elementSpacing;
            const startX = centerX - totalWidth / 2;

            // Draw array elements
            const colors = ['#4caf50', '#2196f3', '#ff9800', '#9c27b0', '#f44336', '#00bcd4', '#795548', '#607d8b'];
            
            elements.forEach((element, i) => {
                const x = startX + i * elementSpacing;
                const y = centerY;

                // Draw element circle
                arrayCtx.fillStyle = colors[i % colors.length];
                arrayCtx.beginPath();
                arrayCtx.arc(x, y, 15, 0, 2 * Math.PI);
                arrayCtx.fill();

                // Element number
                arrayCtx.fillStyle = 'white';
                arrayCtx.font = '12px Arial';
                arrayCtx.textAlign = 'center';
                arrayCtx.fillText((i+1).toString(), x, y + 4);

                // Element parameters
                arrayCtx.fillStyle = '#333';
                arrayCtx.font = '10px Arial';
                arrayCtx.fillText(`A:${element.amplitude.toFixed(1)}`, x, y + 28);
                arrayCtx.fillText(`φ:${element.phase.toFixed(0)}°`, x, y + 40);

                // Draw phase vector
                const vectorLength = 30;
                const vectorY = y + 80;
                const phaseRad = element.phase * Math.PI / 180;
                const vecX = element.amplitude * vectorLength * Math.cos(phaseRad);
                const vecY = element.amplitude * vectorLength * Math.sin(phaseRad);
                
                arrayCtx.strokeStyle = colors[i % colors.length];
                arrayCtx.lineWidth = 2;
                arrayCtx.beginPath();
                arrayCtx.moveTo(x, vectorY);
                arrayCtx.lineTo(x + vecX, vectorY - vecY);
                arrayCtx.stroke();
                
                // Draw arrowhead
                if (element.amplitude > 0.1) {
                    const arrowAngle = Math.atan2(-vecY, vecX);
                    const arrowX = x + vecX;
                    const arrowY = vectorY - vecY;
                    arrayCtx.beginPath();
                    arrayCtx.moveTo(arrowX, arrowY);
                    arrayCtx.lineTo(arrowX - 6*Math.cos(arrowAngle-0.3), arrowY + 6*Math.sin(arrowAngle-0.3));
                    arrayCtx.lineTo(arrowX - 6*Math.cos(arrowAngle+0.3), arrowY + 6*Math.sin(arrowAngle+0.3));
                    arrayCtx.closePath();
                    arrayCtx.fillStyle = colors[i % colors.length];
                    arrayCtx.fill();
                }
            });

            // Draw spacing dimension
            if (elements.length > 1) {
                arrayCtx.strokeStyle = '#666';
                arrayCtx.lineWidth = 1;
                arrayCtx.setLineDash([5, 5]);
                arrayCtx.beginPath();
                arrayCtx.moveTo(startX, centerY - 40);
                arrayCtx.lineTo(startX + elementSpacing, centerY - 40);
                arrayCtx.stroke();
                arrayCtx.setLineDash([]);
                
                arrayCtx.fillStyle = '#333';
                arrayCtx.font = '12px Arial';
                arrayCtx.textAlign = 'center';
                arrayCtx.fillText(`${spacing}λ`, startX + elementSpacing/2, centerY - 50);
            }

            arrayCtx.fillStyle = '#333';
            arrayCtx.textAlign = 'center';
            arrayCtx.fillText('Phase Vectors', centerX, centerY + 140);
        }

        function drawPlots() {
            drawPolarPlot();
            drawArrayGeometry();
        }

        function resetElements() {
            elements.forEach(element => {
                element.amplitude = 1.0;
                element.phase = 0.0;
            });
            createElementControls();
            updateDisplay();
        }

        function randomizeElements() {
            elements.forEach(element => {
                element.amplitude = 0.5 + Math.random() * 1.0; // 0.5 to 1.5
                element.phase = (Math.random() - 0.5) * 360; // -180 to +180
            });
            createElementControls();
            updateDisplay();
        }

        function adaptiveNulling() {
            const spacing = parseFloat(spacingSlider.value);
            const targetAngle = parseFloat(nullAngleSlider.value);
            
            // Simple gradient descent for phase optimization
            const learningRate = 0.1;
            const iterations = 100;
            
            let bestConfig = elements.map(el => ({...el}));
            let bestNullDepth = 0;
            
            // Try multiple random starting points
            for (let trial = 0; trial < 10; trial++) {
                // Start with current configuration
                let testElements = elements.map(el => ({...el}));
                
                for (let iter = 0; iter < iterations; iter++) {
                    // Try small phase adjustments for each element
                    testElements.forEach((element, i) => {
                        if (i === 0) return; // Keep first element as reference
                        
                        const originalPhase = element.phase;
                        
                        // Try phase + delta
                        element.phase += 5;
                        const af1 = calculateMultiElementArrayFactor(targetAngle, spacing, testElements);
                        
                        // Try phase - delta
                        element.phase = originalPhase - 5;
                        const af2 = calculateMultiElementArrayFactor(targetAngle, spacing, testElements);
                        
                        // Keep the better one
                        if (af2 < af1) {
                            // af2 is better (smaller signal at null angle)
                        } else {
                            element.phase = originalPhase + 5;
                            const af3 = calculateMultiElementArrayFactor(targetAngle, spacing, testElements);
                            if (af3 >= af1) {
                                element.phase = originalPhase; // No improvement
                            }
                        }
                        
                        // Wrap phase
                        while (element.phase > 180) element.phase -= 360;
                        while (element.phase < -180) element.phase += 360;
                    });
                }
                
                // Evaluate this configuration
                const finalAF = calculateMultiElementArrayFactor(targetAngle, spacing, testElements);
                const maxAF = Math.max(...Array.from({length: 360}, (_, i) => 
                    calculateMultiElementArrayFactor(i, spacing, testElements)
                ));
                const nullDepth = maxAF > 0 ? -20 * Math.log10(finalAF / maxAF) : 0;
                
                if (nullDepth > bestNullDepth) {
                    bestNullDepth = nullDepth;
                    bestConfig = testElements.map(el => ({...el}));
                }
            }
            
            // Apply best configuration
            elements.forEach((element, i) => {
                element.phase = bestConfig[i].phase;
            });
            
            createElementControls();
            updateDisplay();
            
            setTimeout(() => {
                alert(`Adaptive Nulling Complete!\n` +
                      `• Target angle: ${targetAngle}°\n` +
                      `• Achieved null depth: ${bestNullDepth.toFixed(1)} dB\n` +
                      `• Used ${elements.length} elements\n\n` +
                      `Try adding more elements for even better nulling!`);
            }, 100);
        }

        function onNumElementsChange() {
            const newNum = parseInt(numElementsSlider.value);
            initializeElements(newNum);
            createElementControls();
            updateDisplay();
        }

        // Event listeners
        numElementsSlider.addEventListener('input', onNumElementsChange);
        spacingSlider.addEventListener('input', updateDisplay);
        nullAngleSlider.addEventListener('input', updateDisplay);
        resetBtn.addEventListener('click', resetElements);
        randomizeBtn.addEventListener('click', randomizeElements);
        adaptiveNullBtn.addEventListener('click', adaptiveNulling);

        // Initialize
        initializeElements(2);
        createElementControls();
        updateDisplay();
    </script>
</body>
</html>